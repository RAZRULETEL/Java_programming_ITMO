package Server.network_modules;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.lang.reflect.Field;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Timestamp;
import java.sql.Types;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import Shared.resources.Coordinates;
import Shared.resources.Location;
import Shared.resources.Route;


public class DBHandler {
    private static final Logger logger = LoggerFactory.getLogger(DBHandler.class);
    private Connection connection;
    public DBHandler(String url, String user, String password) throws SQLException {
        connection = DriverManager.getConnection(url, user, password);
        connection.prepareStatement("CREATE TABLE IF NOT EXISTS \"routes\" (\n" +
                "  \"id\" INT GENERATED BY DEFAULT AS IDENTITY UNIQUE PRIMARY KEY,\n" +
                "  \"key\" int UNIQUE NOT NULL,\n" +
                "  \"name\" text NOT NULL,\n" +
                "  \"coords_id\" int NOT NULL,\n" +
                "  \"creation_date\" timestamp NOT NULL,\n" +
                "  \"location_from_id\" int NOT NULL,\n" +
                "  \"location_to_id\" int,\n" +
                "  \"distance\" int,\n" +
                "  \"user_login\" text NOT NULL\n" +
                ");\n" +
                "\n" +
                "CREATE TABLE IF NOT EXISTS \"locations\" (\n" +
                "  \"id\" INT GENERATED BY DEFAULT AS IDENTITY UNIQUE PRIMARY KEY,\n" +
                "  \"x\" double precision NOT NULL,\n" +
                "  \"y\" real NOT NULL,\n" +
                "  \"z\" double precision NOT NULL,\n" +
                "  \"name\" text NOT NULL\n" +
                ");\n" +
                "\n" +
                "CREATE TABLE IF NOT EXISTS \"coordinates\" (\n" +
                "  \"id\" INT GENERATED BY DEFAULT AS IDENTITY UNIQUE PRIMARY KEY,\n" +
                "  \"x\" double precision NOT NULL,\n" +
                "  \"y\" int NOT NULL\n" +
                ");\n" +
                "\n" +
                "CREATE TABLE IF NOT EXISTS \"users\" (\n" +
                "  \"login\" text UNIQUE NOT NULL,\n" +
                "  \"password\" bytea NOT NULL\n" +
                ");\n" +
                "\n" +
                "ALTER TABLE \"routes\" ADD FOREIGN KEY (\"coords_id\") REFERENCES \"coordinates\" (\"id\");\n" +
                "\n" +
                "ALTER TABLE \"routes\" ADD FOREIGN KEY (\"location_from_id\") REFERENCES \"locations\" (\"id\");\n" +
                "\n" +
                "ALTER TABLE \"routes\" ADD FOREIGN KEY (\"location_to_id\") REFERENCES \"locations\" (\"id\");\n" +
                "\n" +
                "ALTER TABLE \"routes\" ADD FOREIGN KEY (\"user_login\") REFERENCES \"users\" (\"login\");\n").execute();

    }

    /**
     * Adds record to the coordinates table of DB
     * @param key route key
     * @param route object to insert to DB
     * @return id of inserted row/object
     */
    public int addRoute(int key, Route route, String userLogin) {
        int coords_id = addCoordinates(route.getCoordinates());
        int loc_from_id = addLocation(route.getFrom());
        int loc_to_id = route.getTo() == null ? -1 : addLocation(route.getTo());

        if(coords_id == -1 || loc_from_id == -1)
            throw new IllegalStateException("DB does not contains required records to add Route");

        try {
            SQLRequests req = SQLRequests.addRoute;
            PreparedStatement pstmt = connection.prepareStatement(req.toStatement());
            pstmt.setInt(req.getDataFieldPosition(RequestField.KEY), key);
            pstmt.setString(req.getDataFieldPosition(RequestField.NAME), route.getName());
            pstmt.setInt(req.getDataFieldPosition(RequestField.COORDINATES_ID), coords_id);
            pstmt.setTimestamp(req.getDataFieldPosition(RequestField.CREATION_DATE), Timestamp.from(route.getCreationDate().toInstant()));
            pstmt.setInt(req.getDataFieldPosition(RequestField.LOCATION_FROM_ID), loc_from_id);

            if(loc_to_id == -1)
                pstmt.setNull(req.getDataFieldPosition(RequestField.LOCATION_TO_ID), Types.INTEGER);
            else
                pstmt.setInt(req.getDataFieldPosition(RequestField.LOCATION_TO_ID), loc_to_id);

            if(route.getDistance() == null)
                pstmt.setNull(req.getDataFieldPosition(RequestField.DISTANCE), Types.INTEGER);
            else
                pstmt.setInt(req.getDataFieldPosition(RequestField.DISTANCE), route.getDistance());

            pstmt.setString(req.getDataFieldPosition(RequestField.ROUTE_LOGIN), userLogin);
            ResultSet rs = pstmt.executeQuery();
            return rs.next() ? rs.getInt("id") : -1;
        } catch (SQLException e) {
            logger.error("Error inserting Route to DB, sql query: {}", SQLRequests.addRoute.toStatement());
            return -1;
        }
    }


    /**
     * Updates record of DB
     * @param key route key
     * @param route object to insert to DB
     * @return 1 if route updated, else =< 0
     */
    public int updateRoute(int key, Route route) {
        try {
            SQLRequests req = SQLRequests.updateRoute;
            PreparedStatement pstmt = connection.prepareStatement(req.toStatement());
            pstmt.setInt(req.getDataFieldPosition(RequestField.KEY), key);
            pstmt.setString(req.getDataFieldPosition(RequestField.NAME), route.getName());
            pstmt.setDouble(req.getDataFieldPosition(RequestField.DISTANCE), route.getDistance());
            pstmt.setInt(req.getConditionFieldPosition(RequestField.KEY), key);
            ResultSet rs = pstmt.executeQuery();
            if(!rs.next()) return -1;
            updateCoordinates(rs.getInt("coords_id"), route.getCoordinates());
            updateLocation(rs.getInt("location_from_id"), route.getFrom());
            if(rs.getString("location_to_id") == null && route.getTo() != null){
                PreparedStatement pstmtLoc = connection.prepareStatement(SQLRequests.updateLocationId.toStatement());
                pstmtLoc.setInt(req.getDataFieldPosition(RequestField.LOCATION_TO_ID), addLocation(route.getTo()));
                pstmtLoc.setInt(req.getConditionFieldPosition(RequestField.KEY), key);
                int rsUpdate = pstmtLoc.executeUpdate();
                if(rsUpdate < 1) return -1;
            };
            if(rs.getString("location_to_id") != null && route.getTo() == null){
                PreparedStatement pstmtLoc = connection.prepareStatement(SQLRequests.updateLocationId.toStatement());
                pstmtLoc.setInt(req.getConditionFieldPosition(RequestField.KEY), key);
                int rsUpdate = pstmtLoc.executeUpdate();
                if(rsUpdate < 1) return -1;
            }
            if(rs.getString("location_to_id") != null && route.getTo() != null)
                updateLocation(rs.getInt("location_to_id"), route.getTo());
            return rs.next() ? rs.getInt("id") : -1;
        } catch (SQLException e) {
            logger.error("Error updating Route to DB, sql query: {}", SQLRequests.updateRoute.toStatement());
            return -1;
        }
    }


    private void updateLocation(int id, Location location){
        try {
            SQLRequests req = SQLRequests.updateLocation;
            PreparedStatement statement = connection.prepareStatement(req.toStatement());
            statement.setDouble(req.getDataFieldPosition(RequestField.X), location.getX());
            statement.setFloat(req.getDataFieldPosition(RequestField.Y), location.getY());
            statement.setDouble(req.getDataFieldPosition(RequestField.Z), location.getZ());
            statement.setString(req.getDataFieldPosition(RequestField.NAME), location.getName());
            statement.setInt(req.getConditionFieldPosition(RequestField.ID), id);
            int rs = statement.executeUpdate();
        } catch (SQLException e) {
            logger.error("Error update Location to DB, sql query: {}", SQLRequests.updateLocation.toStatement());
        }
    }

    private void updateCoordinates(int id, Coordinates coords){
        try {
            SQLRequests req = SQLRequests.updateCoordinates;
            PreparedStatement statement = connection.prepareStatement(req.toStatement());
            statement.setDouble(req.getDataFieldPosition(RequestField.X), coords.getX());
            statement.setInt(req.getDataFieldPosition(RequestField.Y), coords.getY());
            statement.setInt(req.getConditionFieldPosition(RequestField.ID), id);
            int rs = statement.executeUpdate();
        } catch (SQLException e) {
            logger.error("Error update Coordinates to DB, sql query: {}", SQLRequests.updateCoordinates.toStatement());
        }
    }

    /**
     * Adds record to the coordinates table of DB
     * @param coordinates object to insert to DB
     * @return id of inserted row/object
     */
    private int addCoordinates(Coordinates coordinates) {
        SQLRequests req = SQLRequests.addCoordinates;
        try (PreparedStatement pstmt = connection.prepareStatement(req.toStatement())) {
            pstmt.setDouble(req.getDataFieldPosition(RequestField.X), coordinates.getX());
            pstmt.setInt(req.getDataFieldPosition(RequestField.Y), coordinates.getY());
            ResultSet rs = pstmt.executeQuery();
            return rs.next() ? rs.getInt("id") : -1;
        } catch (SQLException e) {
            logger.error("Error inserting Coordinates to DB, sql query: {}", SQLRequests.addCoordinates.toStatement());
            return -1;
        }
    }


    /**
     * Adds record to the locations table of DB
     * @param location object to insert to DB
     * @return id of inserted row/object
     */
    private Integer addLocation(Location location){
        SQLRequests req = SQLRequests.addLocation;
            try (PreparedStatement pstmt = connection.prepareStatement(req.toStatement())) {
                pstmt.setDouble(req.getDataFieldPosition(RequestField.X), location.getX());
                pstmt.setFloat(req.getDataFieldPosition(RequestField.Y), location.getY());
                pstmt.setDouble(req.getDataFieldPosition(RequestField.Z), location.getZ());
                pstmt.setString(req.getDataFieldPosition(RequestField.NAME), location.getName());
                ResultSet rs = pstmt.executeQuery();
                return rs.next() ? rs.getInt("id") : -1;
            } catch (SQLException e) {
                logger.error("Error inserting Location to DB, sql query: {}", SQLRequests.addLocation.toStatement());
                return -1;
            }
        }


    public HashMap<Integer, Route> loadCollection() throws SQLException, NoSuchFieldException{
        Statement statement = connection.createStatement();

        ResultSet rs = statement.executeQuery(SQLRequests.getFullCollection.toStatement());
        HashMap<Integer, Route> collection = new HashMap<>();
        while (rs.next()) {
            try {
                int id = rs.getInt("id");
                Route route = collection.getOrDefault(id, new Route());

                // Set Route fields using reflection
                Class<Route> routeClass = Route.class;

                Field idField = routeClass.getDeclaredField("id");
                idField.setAccessible(true);
                idField.set(route, id);

                Field nameField = routeClass.getDeclaredField("name");
                nameField.setAccessible(true);
                nameField.set(route, rs.getString("name"));

                Field coordinatesField = routeClass.getDeclaredField("coordinates");
                coordinatesField.setAccessible(true);
                Coordinates coordinates = new Coordinates();
                coordinates.setX(rs.getDouble("coordinates_x"));
                coordinates.setY(rs.getInt("coordinates_y"));
                coordinatesField.set(route, coordinates);

                Field creationDateField = routeClass.getDeclaredField("creationDate");
                creationDateField.setAccessible(true);
                Timestamp timestamp = rs.getTimestamp("creation_date");
                ZonedDateTime creationDate = ZonedDateTime.ofInstant(timestamp.toInstant(), ZoneOffset.UTC);
                creationDateField.set(route, creationDate);

                Field fromField = routeClass.getDeclaredField("from");
                fromField.setAccessible(true);
                Location fromLocation = new Location();
                fromLocation.setX(rs.getDouble("location_from_x"));
                fromLocation.setY(rs.getFloat("location_from_y"));
                fromLocation.setZ(rs.getDouble("location_from_z"));
                fromLocation.setName(rs.getString("location_from_name"));
                fromField.set(route, fromLocation);

                Field toField = routeClass.getDeclaredField("to");
                toField.setAccessible(true);
                if (rs.getString("location_to_name") != null) {
                    Location toLocation = new Location();
                    toLocation.setX(rs.getDouble("location_to_x"));
                    toLocation.setY(rs.getFloat("location_to_y"));
                    toLocation.setZ(rs.getDouble("location_to_z"));
                    toLocation.setName(rs.getString("location_to_name"));
                    toField.set(route, toLocation);
                }

                Field distanceField = routeClass.getDeclaredField("distance");
                distanceField.setAccessible(true);
                distanceField.set(route, rs.getString("distance") == null ? null : Integer.parseInt(rs.getString("distance")));

                // Add the Route object to the HashMap
                collection.put(rs.getInt("key"), route);
            }catch (IllegalAccessException e){
                logger.error("Error set field, access error: "+e.getMessage());
            }
        }
        return collection;
    }

    public int deleteRoute(int id) {
        try (PreparedStatement stmt = connection.prepareStatement(SQLRequests.deleteRoute.toStatement())) {
            stmt.setInt(SQLRequests.deleteRoute.getConditionFieldPosition(RequestField.ID), id);
            ResultSet rs = stmt.executeQuery();
            if (!rs.next())
                return -1;
            clearTableByIDs(Tables.COORDINATES, rs.getInt("coords_id"));
            clearTableByIDs(Tables.LOCATIONS, rs.getInt("location_to_id"), rs.getInt("location_from_id"));
            return 1;
        } catch (SQLException e) {
            logger.error("Error deleting Route from DB, sql query: {}, message: {}", SQLRequests.deleteRoute.toStatement(), e.getMessage());
            return -1;
        }
    }


    private void clearTableByIDs(Tables table, int... ids) {
        if (!table.isCanBeDeletedWithIdOnly())
            throw new IllegalArgumentException("Удаление из этой таблицы данным способом запрещено");

        StringBuilder sql = new StringBuilder("DELETE FROM ").append(table.getName()).append(" WHERE ");

        if (ids.length == 0)
            return;

        for (int i = 0; i < ids.length; i++) {
            if (ids[i] >= 0) {
                sql.append("id = ?");
                if (i != ids.length - 1)
                    sql.append(" OR ");
            }
        }

        try (PreparedStatement stmt = connection.prepareStatement(sql.toString())) {
            int index = 1;
            for (int id : ids) {
                if (id >= 0) {
                    stmt.setInt(index, id);
                    index++;
                }
            }
            stmt.executeUpdate();
        } catch (SQLException e) {
            logger.error("Error deleting records in {} from DB, sql query: {}", table.getName(), sql);
        }
    }




    /**
     *
     * @return keys of deleted objects
     */
    public int[] clearByLogin(String login) {
        try (PreparedStatement statement = connection.prepareStatement(SQLRequests.clearRoutesByLogin.toStatement())) {
            statement.setString(SQLRequests.clearRoutesByLogin.getConditionFieldPosition(RequestField.ROUTE_LOGIN), login);
            ResultSet rs = statement.executeQuery();
            ArrayList<Integer> coords_ids = new ArrayList<>();
            ArrayList<Integer> ids = new ArrayList<>();
            ArrayList<Integer> locs_ids = new ArrayList<>();
            while (rs.next()){
                ids.add(rs.getInt("key"));
                coords_ids.add(rs.getInt("coords_id"));
                locs_ids.add(rs.getInt("location_from_id"));
                if(rs.getString("location_to_id") != null) locs_ids.add(rs.getInt("location_to_id"));
            }
            final int[] coords_arr = new int[coords_ids.size()];
            Arrays.setAll(coords_arr, coords_ids::get);
            clearTableByIDs(Tables.COORDINATES, coords_arr);

            final int[] locs_arr = new int[locs_ids.size()];
            Arrays.setAll(locs_arr, locs_ids::get);
            clearTableByIDs(Tables.LOCATIONS, locs_arr);

            final int[] ids_arr = new int[ids.size()];
            Arrays.setAll(ids_arr, ids::get);
            return ids_arr;
        } catch (SQLException e) {
            logger.error("Error deleting Routes from DB, sql query: {}, message: {}", SQLRequests.clearRoutesByLogin.toStatement(), e.getMessage());
            return null;
        }
    }

    public HashMap<String, ArrayList<Integer>> getUsersObjects(){
        try {
            ResultSet rs = connection.createStatement().executeQuery(SQLRequests.getUserToObjMap.toStatement());
            HashMap<String, ArrayList<Integer>> result = new HashMap<String, ArrayList<Integer>>();
            while (rs.next()){
                if(!result.containsKey(rs.getString("user_login")))
                    result.put(rs.getString("user_login"), new ArrayList<>());
                if(rs.getString("id") != null)
                    result.get(rs.getString("user_login")).add(rs.getInt("id"));
            }
            return result;
        } catch (SQLException e) {
            logger.error("Error getting user objects, sql query: {}", SQLRequests.getUserToObjMap.toStatement());
            return null;
        }
    }

    public boolean checkUserAuth(String login, String password) {
        try {
            try {
                PreparedStatement st = connection.prepareStatement(SQLRequests.checkUserAuth.toStatement());
                st.setString(SQLRequests.checkUserAuth.getConditionFieldPosition(RequestField.LOGIN), login);
                st.setBytes(SQLRequests.checkUserAuth.getConditionFieldPosition(RequestField.PASSWORD), MessageDigest.getInstance("SHA-256").digest(password.getBytes()));
                ResultSet rs = st.executeQuery();
                return rs.next();
            } catch (SQLException e) {
                    logger.error("Error auth checking, sql query: {}", SQLRequests.checkUserAuth.toStatement());
                return false;
            }
        }catch (NoSuchAlgorithmException e){
            logger.error("Java can't find required algorithm to hash password");
            return false;
        }
    }

    public boolean checkUserExists(String login){
        try {
            PreparedStatement st = connection.prepareStatement(SQLRequests.checkUserLogin.toStatement());
            st.setString(SQLRequests.checkUserLogin.getConditionFieldPosition(RequestField.LOGIN), login);
            ResultSet rs = st.executeQuery();
            return rs.next();
        } catch (SQLException e) {
            logger.error("Error user checking, sql query: {}", SQLRequests.checkUserLogin.toStatement());
            return false;
        }
    }

    public boolean registerUser(String login, String password) {
        try {
            try {
                PreparedStatement st = connection.prepareStatement(SQLRequests.registerUser.toStatement());
                st.setString(SQLRequests.registerUser.getDataFieldPosition(RequestField.LOGIN), login);
                st.setBytes(SQLRequests.registerUser.getDataFieldPosition(RequestField.PASSWORD), MessageDigest.getInstance("SHA-256").digest(password.getBytes()));
                int rs = st.executeUpdate();
                return rs == 1;
            } catch (SQLException e) {
                    logger.error("Error register user, sql query: {}, message: {}", SQLRequests.registerUser.toStatement(), e.getMessage());
                return false;
            }
        }catch (NoSuchAlgorithmException e){
            logger.error("Java can't find required algorithm to hash password");
            return false;
        }
    }

    @Override
    public String toString() {
        return "DBHandler{" +
                "connection=" + connection +
                '}';
    }
    private enum Tables{
        ROUTES("routes", false), LOCATIONS("locations", true), COORDINATES("coordinates", true);
        private String name;
        private boolean canBeDeletedWithIdOnly;
        Tables(String nameInDB, boolean canDeleteById) {
            this.name = nameInDB;
            canBeDeletedWithIdOnly = canDeleteById;
        }

        public String getName() {
            return name;
        }

        public boolean isCanBeDeletedWithIdOnly() {
            return canBeDeletedWithIdOnly;
        }
    }
}
enum SQLRequests{
        getFullCollection("""
    SELECT
        routes.id,
        routes.key,
        routes.name,
        coordinates.x AS coordinates_x,
        coordinates.y AS coordinates_y,
        location_from.x AS location_from_x,
        location_from.y AS location_from_y,
        location_from.z AS location_from_z,
        location_from.name AS location_from_name,
        routes.creation_date,
        location_to.x AS location_to_x,
        location_to.y AS location_to_y,
        location_to.z AS location_to_z,
        location_to.name AS location_to_name,
        routes.distance
    FROM
        routes
        INNER JOIN coordinates ON routes.coords_id = coordinates.id
        INNER JOIN locations AS location_from ON routes.location_from_id = location_from.id
        LEFT JOIN locations AS location_to ON routes.location_to_id = location_to.id;
                """),
        getUserToObjMap("SELECT users.login AS user_login, routes.id AS id FROM users LEFT JOIN routes ON users.login = routes.user_login;"),

        addRoute("INSERT INTO routes (key, name, distance, user_login, creation_date, coords_id, location_from_id, location_to_id) "
                + "VALUES (?, ?, ?, ?, ?, ?, ?, ?) RETURNING id;"),
        addLocation("INSERT INTO locations (x, y, z, name) VALUES (?, ?, ?, ?) RETURNING id;"),
        addCoordinates("INSERT INTO coordinates (x, y) VALUES (?, ?) RETURNING id;"),

        updateRoute("UPDATE routes SET key = ?, name = ?, distance = ? WHERE key = ? RETURNING coords_id, location_from_id, location_to_id;"),
        updateLocationId("UPDATE routes SET location_to_id = ? WHERE key = ?"),
        updateLocation("UPDATE locations SET (x, y, z, name) = (?, ?, ?, ?) WHERE id = ?;"),
        updateCoordinates("UPDATE coordinates SET (x, y) = (?, ?) WHERE id = ?;"),

        deleteRoute("DELETE FROM routes WHERE id = ? RETURNING coords_id, location_from_id, location_to_id;"),
        clearRoutesByLogin("DELETE FROM routes WHERE user_login = ? RETURNING coords_id, location_from_id, location_to_id, key;"),

        registerUser("INSERT INTO users(login, password) VALUES(?, ?);"),
        checkUserAuth("SELECT * FROM users WHERE users.login = ? AND users.password = ?;"),
        checkUserLogin("SELECT login FROM users WHERE users.login = ?;");
    private final String statement;

    private RequestField[] dataFields, conditionsFields;

    SQLRequests(String statement){
        this.statement = statement;

        //Filling data fileds
        String dataPart = statement.split("WHERE")[0];

        Pattern pattern = Pattern.compile("((?<=\\(([\\w,\\s]*))\\w+(?=([\\w,\\s]*)\\))|\\w+(?=\\s*=\\s*\\?\\s*(\\|\\s*\\?)?))");
        // Create a regex pattern to match placeholders, divided by two parts, first detect in INSERT, second in UPDATE
        Matcher matcher = pattern.matcher(dataPart);

        ArrayList<RequestField> dataFields = new ArrayList<RequestField>();
        while(matcher.find()){
            dataFields.add(RequestField.strToField(matcher.group()));
        }
        this.dataFields = dataFields.toArray(new RequestField[0]);

        //Filling conditions fields
        if(statement.contains("WHERE")){
            String condPart = statement.split("WHERE")[1];
            if(condPart.contains("?")){
                Pattern conditionPattern = Pattern.compile("\\w+(?=\\s*=\\s*\\?\\s*(\\|\\s*\\?)?)"); // Create a regex pattern to match placeholders
                matcher = conditionPattern.matcher(condPart);
                ArrayList<RequestField> condFields = new ArrayList<>();
                while(matcher.find()){
                    String match = matcher.group();
                    condFields.add(RequestField.strToField(match));
                }
                conditionsFields = condFields.toArray(new RequestField[0]);
            }
        }
    }
    public String toStatement(){return statement;}
    public int getDataFieldPosition(RequestField field) {
        if(dataFields == null)
            throw new UnsupportedOperationException("Данный запрос не содержит полей данного типа");
        for (int i = 0; i < dataFields.length; i++) {
            if (dataFields[i] == field) {
                return i+1;
            }
        }
        return -1;
    }

    public int getDataFieldsCount(){
        return dataFields == null ? 0 : dataFields.length;
    }

    public int getConditionFieldPosition(RequestField field) {
        if(conditionsFields == null)
            throw new UnsupportedOperationException("Данный запрос не содержит полей данного типа");
        for (int i = 0; i < conditionsFields.length; i++) {
            if (conditionsFields[i] == field) {
                return getDataFieldsCount()+i+1;
            }
        }
        return -1;
    }

    @Override
    public String toString() {
        return "SQLRequests{" +
                "statement='" + statement + '\'' +
                ", dataFields=" + Arrays.toString(dataFields) +
                ", conditionsFields=" + Arrays.toString(conditionsFields) +
                '}';
    }
}
enum RequestField{
    KEY("key"), NAME("name"), DISTANCE("distance"), ROUTE_LOGIN("user_login"),
    COORDINATES_ID("coords_id"), LOCATION_FROM_ID("location_from_id"), LOCATION_TO_ID("location_to_id"),
    X("x"), Y("y"), Z("z"), ID("id"), LOGIN("login"), PASSWORD("password"),
    CREATION_DATE("creation_date");
    private final String strInDB;
    RequestField(String stringNameInDB){
        strInDB = stringNameInDB;
    }
    public String getStringName(){return strInDB;}
    static RequestField strToField(String string){
        for (RequestField field : RequestField.values()) {
            if (field.strInDB.equals(string.trim())) {
                return field;
            }
        }
        return null;
    }
}
